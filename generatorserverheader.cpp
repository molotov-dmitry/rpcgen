#include "generatorserverheader.h"

#include "utils.h"

GeneratorServerHeader::GeneratorServerHeader(const Settings& settings) : Generator(settings)
{

}

void GeneratorServerHeader::generate(std::ostream& stream)
{
    std::string defineName = to_upper(mSettings.rpcName()) + "_H";

    //// Code guard start ======================================================

    stream << "#ifndef " << defineName << std::endl;
    stream << "#define " << defineName << std::endl;

    stream << std::endl;

    //// Autogenerated file notify =============================================

    stream << "// File generated by rpcgen tool. All changes will be lost." << std::endl;

    stream << std::endl;

    //// Includes ==============================================================

    for (const std::string& include : mSettings.includes())
    {
        stream << "#include " << include << std::endl;
    }

    if (not mSettings.includes().empty())
    {
        stream << std::endl;
    }

    //// Type definitions ======================================================

    stream << "typedef " << mSettings.returnType() << "(*RPC_F)();" << std::endl;

    stream << std::endl;

    //// Function declarations =================================================

    stream << mSettings.returnType() << " call_" << mSettings.rpcName() << "(unsigned int id, void* buf_in, int in_len, void* buf_out, int* out_len);" << std::endl;

    stream << std::endl;

    //// Enum ==================================================================

    if (mSettings.needEnumInHeader())
    {
        stream << "enum" << std::endl;

        stream << "{" << std::endl;

        for (const Data& data : mSettings.data())
        {
            if (data.type == DATA_MACRO)
            {
                stream << data.name << std::endl;
            }
            else if (data.type == DATA_METHOD)
            {
                stream << "    cmd_" << data.name << "," << std::endl;
            }
        }

        stream << "    n_cmd_" << mSettings.rpcName() << std::endl;

        stream << "};" << std::endl;

        stream << std::endl;
    }

    //// Server parameters structure ===========================================

    if (not mSettings.serverParametersKeys().empty())
    {
        std::map<std::string, Args> serverParameters = mSettings.serverParameters();

        stream << "struct " << mSettings.rpcName() << "_srvr" << std::endl;

        stream << "{" << std::endl;

        for (const std::string& param : mSettings.serverParametersKeys())
        {
            stream << "    " << serverParameters[param].type << " " << param << ";" << std::endl;
        }

        stream << "};" << std::endl;

        stream << std::endl;
    }

    //// RPC item ==============================================================

    stream << "struct " << mSettings.rpcName() << "_rpc_item" << std::endl;

    stream << "{" << std::endl;

    stream << "    RPC_F f;" << std::endl;
    stream << "    int   in_len;" << std::endl;
    stream << "    int   out_len;" << std::endl;
    stream << "    int   flags;" << std::endl;

    if (not mSettings.serverParametersKeys().empty())
    {
        stream << "    " << mSettings.rpcName() << "_srvr param;" << std::endl;
    }

    stream << "};" << std::endl;

    stream << std::endl;

    //// RPC items array =======================================================

    stream << "extern const " << mSettings.rpcName() << "_rpc_item " << mSettings.rpcName() << "_rpc_tab[];" << std::endl;

    stream << std::endl;

    //// Methods list ==========================================================

    bool dataStarted = false;

    for (const Data& data : mSettings.data())
    {
        if (not dataStarted)
        {
            if (data.type == DATA_EMPTY_LINE)
            {
                continue;
            }
            else
            {
                dataStarted = true;
            }
        }

        if (data.type == DATA_MACRO)
        {
            stream << data.name << std::endl;
        }
        else if (data.type == DATA_METHOD)
        {
            std::list<std::string> parameters;

            if (not data.in.type.empty())
            {
                std::string param = data.in.type;

                if (not data.in.noptr)
                {
                    param += "* in";
                }
                else
                {
                    param += " in";
                }

                if (data.in.varLen)
                {
                    param += ", int in_len";
                }

                parameters.push_back(param);
            }

            if (not data.out.type.empty())
            {
                std::string param = data.out.type;

                if (not data.out.noptr)
                {
                    param += "* out";
                }
                else
                {
                    param += " out";
                }

                if (data.out.varLen)
                {
                    param += ", int* out_len";
                }

                parameters.push_back(param);
            }

            stream << mSettings.returnType() << " " << data.name << "(" << join(parameters, ", ") << ");" << std::endl;
        }
        else if (data.type == DATA_EMPTY_LINE)
        {
            stream << std::endl;
        }
        else if (data.type == DATA_COMMENT)
        {
            stream << data.name << std::endl;
        }
    }

    stream << std::endl;

    //// Code guard finish =====================================================

    stream << "#endif //" << defineName << std::endl;

    stream << std::endl;
}
