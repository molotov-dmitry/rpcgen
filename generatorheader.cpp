#include "generatorheader.h"

#include "utils.h"

GeneratorHeader::GeneratorHeader(const Settings& settings, bool generateClient, bool generateServer) :
    Generator(settings),
    mGenerateClient(generateClient),
    mGenerateServer(generateServer)
{

}

void GeneratorHeader::generate(std::ostream& stream)
{
    std::string defineName = to_upper(mSettings.rpcName()) + "_H";

    //// Code guard start ======================================================

    stream << "#ifndef " << defineName << std::endl;
    stream << "#define " << defineName << std::endl;

    stream << std::endl;

    //// Autogenerated file notify =============================================

    stream << autogenerateNotify() << std::endl;
    stream << std::endl;

    //// Includes ==============================================================

    for (const std::string& include : mSettings.includes())
    {
        stream << "#include " << include << std::endl;
    }

    if (not mSettings.includes().empty())
    {
        stream << std::endl;
    }

    //// Type definitions ======================================================

    stream << title("Type definitions") << std::endl;
    stream << std::endl;

    //// Server ----------------------------------------------------------------

    if (mGenerateServer)
    {
        stream << title("Server", 1) << std::endl;
        stream << std::endl;

        stream << "typedef " << mSettings.returnType() << "(*RPC_F)();" << std::endl;

        stream << std::endl;
    }

    //// Parameters ============================================================

    stream << title("Parameters") << std::endl;
    stream << std::endl;

    //// Client ----------------------------------------------------------------

    if (mGenerateClient)
    {
        stream << title("Client", 1) << std::endl;
        stream << std::endl;

        //// RPC item with parameters ------------------------------------------

        stream << "struct " << mSettings.rpcName() << "_clnt" << std::endl;

        stream << "{" << std::endl;

        stream << "    unsigned int id;" << std::endl;
        stream << "    int          send_len;" << std::endl;
        stream << "    int          recv_len;" << std::endl;

        if (not mSettings.clientParametersKeys().empty())
        {
            std::map<std::string, Args> clientParameters = mSettings.clientParameters();

            for (const std::string& param : mSettings.clientParametersKeys())
            {
                stream << "    " << clientParameters[param].type << " " << param << ";" << std::endl;
            }
        }

        stream << "};" << std::endl;

        stream << std::endl;

    }

    //// Server ----------------------------------------------------------------

    if (mGenerateServer)
    {
        stream << title("Server", 1) << std::endl;
        stream << std::endl;

        //// Server parameters structure ---------------------------------------

        if (not mSettings.serverParametersKeys().empty())
        {
            std::map<std::string, Args> serverParameters = mSettings.serverParameters();

            stream << "struct " << mSettings.rpcName() << "_srvr" << std::endl;

            stream << "{" << std::endl;

            for (const std::string& param : mSettings.serverParametersKeys())
            {
                stream << "    " << serverParameters[param].type << " " << param << ";" << std::endl;
            }

            stream << "};" << std::endl;

            stream << std::endl;
        }

        //// RPC item ----------------------------------------------------------

        stream << "struct " << mSettings.rpcName() << "_rpc_item" << std::endl;

        stream << "{" << std::endl;

        stream << "    RPC_F f;" << std::endl;
        stream << "    int   in_len;" << std::endl;
        stream << "    int   out_len;" << std::endl;
        stream << "    int   flags;" << std::endl;

        if (not mSettings.serverParametersKeys().empty())
        {
            stream << "    " << mSettings.rpcName() << "_srvr param;" << std::endl;
        }

        stream << "};" << std::endl;

        stream << std::endl;
    }

    //// RPC items array =======================================================

    stream << title("RPC items") << std::endl;
    stream << std::endl;

    if (mGenerateServer)
    {
        stream << "extern const " << mSettings.rpcName() << "_rpc_item " << mSettings.rpcName() << "_rpc_tab[];" << std::endl;

        stream << std::endl;
    }

    //// Function declarations =================================================

    stream << title("Function declarations") << std::endl;
    stream << std::endl;

    //// Server ----------------------------------------------------------------

    if (mGenerateServer)
    {
        stream << title("Server", 1) << std::endl;
        stream << std::endl;

        std::list<std::string> serverCallParameters;

        if (not mSettings.serverArgs().empty())
        {
            serverCallParameters.push_back(mSettings.serverArgs());
        }

        serverCallParameters.push_back("unsigned int id");
        serverCallParameters.push_back("void* buf_in");
        serverCallParameters.push_back("int in_len");
        serverCallParameters.push_back("void* buf_out");
        serverCallParameters.push_back("int* out_len");

        stream << mSettings.returnType() << " call_" << mSettings.rpcName() << "(" << join(serverCallParameters, ", ") << ");" << std::endl;
        stream << std::endl;

        if (not mSettings.beforeCall().empty())
        {
            stream << mSettings.returnType() << " " << mSettings.beforeCall() << "(const " << mSettings.rpcName() << "_srvr* p);" << std::endl;

            stream << std::endl;
        }

        if (not mSettings.afterCall().empty())
        {
            stream << "void" << " " << mSettings.afterCall() << "(const " << mSettings.rpcName() << "_srvr* p);" << std::endl;

            stream << std::endl;
        }
    }

    //// Client ----------------------------------------------------------------

    if (mGenerateClient)
    {
        stream << title("Client", 1) << std::endl;
        stream << std::endl;

        std::list<std::string> clientSendParameters;

        if (not mSettings.clientArgs().empty())
        {
            clientSendParameters.push_back(mSettings.clientArgs());
        }

        clientSendParameters.push_back("void* in");
        clientSendParameters.push_back("void* out");
        clientSendParameters.push_back(mSettings.rpcName() +  "_clnt* rpc_p");

        std::list<std::string> clientWaitParameters;

        if (not mSettings.clientArgs().empty())
        {
            clientWaitParameters.push_back(mSettings.clientArgs());
        }

        clientWaitParameters.push_back("void* rpc_p");

        stream << mSettings.returnType() << " " << mSettings.funcSend() << "(" << join(clientSendParameters, ", ") << ");" << std::endl;
        stream << std::endl;

        stream << mSettings.returnType() << " " << mSettings.funcRecv() << "(" << join(clientWaitParameters, ", ") << ");" << std::endl;
        stream << std::endl;

    }

    //// Enum ==================================================================

    if (mSettings.needEnumInHeader())
    {
        stream << title("Methods id list") << std::endl;
        stream << std::endl;

        stream << "enum" << std::endl;

        stream << "{" << std::endl;

        for (const Data& data : mSettings.data())
        {
            if (data.type == DATA_MACRO)
            {
                stream << data.name << std::endl;
            }
            else if (data.type == DATA_METHOD)
            {
                stream << "    cmd_" << data.name << "," << std::endl;
            }
        }

        stream << "    n_cmd_" << mSettings.rpcName() << std::endl;

        stream << "};" << std::endl;

        stream << std::endl;
    }

    //// Methods list ==========================================================

    stream << title("Methods") << std::endl;
    stream << std::endl;

    bool dataStarted = false;

    for (const Data& data : mSettings.data())
    {
        if (not dataStarted)
        {
            if (data.type == DATA_EMPTY_LINE)
            {
                continue;
            }
            else
            {
                dataStarted = true;
            }
        }

        if (data.type == DATA_MACRO)
        {
            stream << data.name << std::endl;
        }
        else if (data.type == DATA_METHOD)
        {
            std::list<std::string> parameters;

            if (mGenerateClient)
            {
                if (not mSettings.clientArgs().empty())
                {
                    parameters.push_back(mSettings.clientArgs());
                }
            }
            else if (mGenerateServer)
            {
                if (not mSettings.serverArgs().empty())
                {
                    parameters.push_back(mSettings.serverArgs());
                }
            }

            if (not data.inOut.type.empty())
            {
                std::string param = data.inOut.type;

                if (not data.inOut.noptr)
                {
                    param += "* val";
                }
                else
                {
                    param += " val";
                }

                if (data.inOut.varLen)
                {
                    param += ", int in_len";
                }

                if (data.inOut.varLen)
                {
                    param += ", int* out_len";
                }

                parameters.push_back(param);
            }
            else
            {
                if (not data.in.type.empty())
                {
                    std::string param = data.in.type;

                    if (not data.in.noptr)
                    {
                        param += "* in";
                    }
                    else
                    {
                        param += " in";
                    }

                    if (data.in.varLen)
                    {
                        param += ", int in_len";
                    }

                    parameters.push_back(param);
                }

                if (not data.out.type.empty())
                {
                    std::string param = data.out.type;

                    if (not data.out.noptr)
                    {
                        param += "* out";
                    }
                    else
                    {
                        param += " out";
                    }

                    if (data.out.varLen)
                    {
                        param += ", int* out_len";
                    }

                    parameters.push_back(param);
                }
            }

            stream << mSettings.returnType() << " " << data.name << "(" << join(parameters, ", ") << ");" << std::endl;
        }
        else if (data.type == DATA_EMPTY_LINE)
        {
            stream << std::endl;
        }
        else if (data.type == DATA_COMMENT)
        {
            stream << data.name << std::endl;
        }
    }

    stream << std::endl;

    //// Code guard finish =====================================================

    stream << "#endif //" << defineName << std::endl;

    stream << std::endl;
}
