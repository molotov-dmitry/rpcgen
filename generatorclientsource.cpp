#include "generatorclientsource.h"

#include "utils.h"

GeneratorClientSource::GeneratorClientSource(const Settings &settings) :
    Generator(settings)
{

}

void GeneratorClientSource::generate(std::ostream &stream)
{
    //// Autogenerated file notify =============================================

    stream << autogenerateNotify() << std::endl;
    stream << std::endl;

    //// Include ===============================================================

    stream << "#include \"" << mSettings.rpcName() << ".h\"" << std::endl;
    stream << std::endl;

    //// Enum ==================================================================

    if (not mSettings.needEnumInHeader())
    {
        stream << title("Methods id list") << std::endl;
        stream << std::endl;

        stream << "enum" << std::endl;

        stream << "{" << std::endl;

        for (const Data& data : mSettings.data())
        {
            if (data.type == DATA_MACRO)
            {
                stream << data.name << std::endl;
            }
            else if (data.type == DATA_METHOD)
            {
                stream << "    cmd_" << data.name << "," << std::endl;
            }
        }

        stream << "    n_cmd_" << mSettings.rpcName() << std::endl;

        stream << "};" << std::endl;

        stream << std::endl;
    }

    //// Send and wait method ==================================================

    std::stringlist mSendWaitParameters;
    std::stringlist mSendArguments;
    std::stringlist mWaitArguments;

    if (not mSettings.clientArgs().empty())
    {
        mSendWaitParameters.push_back(mSettings.clientArgs());
        mSendArguments.push_back(after(mSettings.clientArgs(), " "));
        mWaitArguments.push_back(after(mSettings.clientArgs(), " "));
    }

    mSendWaitParameters.push_back("void* in");
    mSendWaitParameters.push_back("void* out");
    mSendWaitParameters.push_back(mSettings.rpcName() + "_clnt* rpc_p");

    mSendArguments.push_back("in");
    mSendArguments.push_back("out");
    mSendArguments.push_back("rpc_p");

    mWaitArguments.push_back("rpc_p");

    stream << mSettings.returnType() << " send_and_wait_" << mSettings.rpcName() << "(" << join(mSendWaitParameters) << ")" << std::endl;

    stream << "{" << std::endl;

    stream << "    " << mSettings.returnType() << " res = " << mSettings.funcSend() << "(" << join(mSendArguments) << ");" << std::endl;

    stream << "    if (res)" << std::endl;
    stream << "    {" << std::endl;
    stream << "        return res;" << std::endl;
    stream << "    }" << std::endl;

    stream << std::endl;

    stream << "    return " << mSettings.funcRecv() << "(" << join(mWaitArguments) << ");" << std::endl;

    stream << "}" << std::endl;

    stream << std::endl;

    //// Methods ===============================================================

    bool dataStarted  = false;
    DataType prevType = DATA_EMPTY_LINE;

    for (const Data& data : mSettings.data())
    {
        if (not dataStarted)
        {
            if (data.type == DATA_EMPTY_LINE)
            {
                continue;
            }
            else
            {
                dataStarted = true;
            }
        }

        //// Add at least empty line between lines -----------------------------

        if (data.type != DATA_COMMENT && data.type != DATA_EMPTY_LINE && prevType != DATA_EMPTY_LINE)
        {
            stream << std::endl;
        }

        prevType = data.type;

        if (data.type == DATA_MACRO || data.type == DATA_COMMENT || data.type == DATA_EMPTY_LINE)
        {
            stream << data.name << std::endl;
        }
        else if (data.type == DATA_METHOD)
        {
            //// Create client method declaration ------------------------------

            std::stringlist parameters;

            std::stringlist parametersSend;
            std::stringlist parametersWait;

            if (not mSettings.clientArgs().empty())
            {
                parameters.push_back(mSettings.clientArgs());
                parametersSend.push_back(mSettings.clientArgs());
                parametersWait.push_back(mSettings.clientArgs());
            }

            if (not data.inOut.type.empty())
            {
                std::string param = data.inOut.type;

                if (not data.inOut.noptr)
                {
                    param += "* val";
                }
                else
                {
                    param += " val";
                }

                parameters.push_back(param);
                parametersSend.push_back(param);
                parametersWait.push_back(param);

                if (data.inOut.varLen)
                {
                    parameters.push_back("int in_len");
                    parametersSend.push_back("int in_len");
                }

                if (data.inOut.varLen)
                {
                    parameters.push_back("int* out_len");
                    parametersWait.push_back("int* out_len");
                }

            }
            else
            {
                if (not data.in.type.empty())
                {
                    std::string param = data.in.type;

                    if (not data.in.noptr)
                    {
                        param += "* in";
                    }
                    else
                    {
                        param += " in";
                    }

                    parameters.push_back(param);
                    parametersSend.push_back(param);

                    if (data.in.varLen)
                    {
                        parameters.push_back("int in_len");
                        parametersSend.push_back("int in_len");
                    }
                }

                if (not data.out.type.empty())
                {
                    std::string param = data.out.type;

                    if (not data.out.noptr)
                    {
                        param += "* out";
                    }
                    else
                    {
                        param += " out";
                    }

                    parameters.push_back(param);
                    parametersSend.push_back(param);

                    if (data.out.varLen)
                    {
                        parameters.push_back("int* out_len");
                        parametersWait.push_back("int* out_len");
                    }
                }
            }

            stream << mSettings.returnType() << " " << data.name << "(" << join(parameters, ", ") << ")" << std::endl;

            //// Client method body --------------------------------------------

            stream << "{" << std::endl;

            //// Client method parameters structure ----------------------------

            std::string inLength = "0";
            std::string outLength = "0";

            if (not data.inOut.type.empty())
            {
                if (data.inOut.varLen)
                {
                    inLength  = "in_len";
                    outLength = "*out_len";
                }
                else if (not data.inOut.size.empty())
                {
                    inLength = data.inOut.size;
                }
                else
                {
                    inLength = string_format("sizeof(%s)", data.inOut.type.c_str());
                    outLength = string_format("sizeof(%s)", data.inOut.type.c_str());
                }
            }
            else
            {
                if (not data.in.type.empty())
                {
                    if (data.in.varLen)
                    {
                        inLength  = "in_len";
                    }
                    else if (not data.in.size.empty())
                    {
                        inLength = data.in.size;
                    }
                    else
                    {
                        inLength = string_format("sizeof(%s)", data.in.type.c_str());
                    }
                }

                if (not data.out.type.empty())
                {
                    if (data.out.varLen)
                    {
                        outLength  = "(*out_len)";
                    }
                    else if (not data.out.size.empty())
                    {
                        outLength = data.out.size;
                    }
                    else
                    {
                        outLength = string_format("sizeof(%s)", data.out.type.c_str());
                    }
                }
            }

            std::list<std::string> clntParameters;

            clntParameters.push_back("cmd_" + data.name);
            clntParameters.push_back(inLength);
            clntParameters.push_back(outLength);

            if (not mSettings.clientParametersKeys().empty())
            {
                std::list<std::string> params;
                std::map<std::string, std::string> mCustomParameters = data.customParameters;
                std::map<std::string, Args> mDefaultParameters = mSettings.clientParameters();

                for (const std::string& param : mSettings.clientParametersKeys())
                {
                    if (contains(mCustomParameters, param))
                    {
                        clntParameters.push_back(mCustomParameters[param]);
                    }
                    else
                    {
                        clntParameters.push_back(mDefaultParameters[param].defaultValue);
                    }
                }
            }

            stream << "    " << mSettings.rpcName() << "_clnt t = {" << join(clntParameters, ", ") << "};" << std::endl;

            stream << std::endl;

            //// Call send and wait method -------------------------------------

            std::stringlist sendWaitArguments;
            std::stringlist sendArguments;
            std::stringlist waitArguments;

            if (not mSettings.clientArgs().empty())
            {
                sendWaitArguments.push_back(after(mSettings.clientArgs(), " "));
                sendArguments.push_back(after(mSettings.clientArgs(), " "));
                waitArguments.push_back(after(mSettings.clientArgs(), " "));
            }

            if (not data.inOut.type.empty())
            {
                sendWaitArguments.push_back("val");
                sendWaitArguments.push_back("val");

                sendArguments.push_back("val");
                sendArguments.push_back("val");
            }
            else
            {
                if (not data.in.type.empty())
                {
                    sendWaitArguments.push_back("in");
                    sendArguments.push_back("in");
                }
                else
                {
                    sendWaitArguments.push_back(nullValue());
                    sendArguments.push_back(nullValue());
                }

                if (not data.out.type.empty())
                {
                    sendWaitArguments.push_back("out");
                    sendArguments.push_back("out");
                }
                else
                {
                    sendWaitArguments.push_back(nullValue());
                    sendArguments.push_back(nullValue());
                }
            }

            sendWaitArguments.push_back("&t");
            sendArguments.push_back("&t");
            waitArguments.push_back("&t");

            if ((not data.inOut.type.empty() && data.inOut.varLen) || (not data.out.type.empty() && data.out.varLen))
            {
                stream << "    " << mSettings.returnType() << " res = send_and_wait_" << mSettings.rpcName() << "(" << join(sendWaitArguments, ", ") << ");" << std::endl;

                stream << std::endl;

                stream << "    *out_len = t.recv_len;" << std::endl;

                stream << std::endl;

                stream << "    return res;" << std::endl;
            }
            else
            {
                stream << "    return send_and_wait_" << mSettings.rpcName() << "(" << join(sendWaitArguments, ", ") << ");" << std::endl;
            }

            //// Client method body --------------------------------------------

            stream << "}" << std::endl;

            //// Separate send and wait methods --------------------------------

            if (data.sendWait)
            {
                //// Send method -----------------------------------------------

                stream << std::endl;

                stream << mSettings.returnType() << " " << data.name << "_send(" << join(parametersSend) << ")" << std::endl;
                stream << "{" << std::endl;

                stream << "    " << mSettings.rpcName() << "_clnt t = {" << join(clntParameters, ", ") << "};" << std::endl;

                stream << std::endl;

                stream << "    return " << mSettings.funcSend() << "(" << join(sendArguments) << ");" << std::endl;

                stream << "}" << std::endl;

                //// Wait method -----------------------------------------------

                stream << std::endl;

                stream << mSettings.returnType() << " " << data.name << "_wait(" << join(parametersWait) << ")" << std::endl;
                stream << "{" << std::endl;

                stream << "    " << mSettings.rpcName() << "_clnt t = {" << join(clntParameters, ", ") << "};" << std::endl;

                stream << std::endl;

                if ((not data.inOut.type.empty() && data.inOut.varLen) || (not data.out.type.empty() && data.out.varLen))
                {
                    stream << "    " << mSettings.returnType() << " res = " << mSettings.funcRecv() << "(" << join(waitArguments, ", ") << ");" << std::endl;

                    stream << std::endl;

                    stream << "    *out_len = t.recv_len;" << std::endl;

                    stream << std::endl;

                    stream << "    return res;" << std::endl;
                }
                else
                {
                    stream << "    return " << mSettings.funcRecv() << "(" << join(waitArguments, ", ") << ");" << std::endl;
                }

                stream << "}" << std::endl;

                //// -----------------------------------------------------------

                stream << std::endl;

            }

            //// ---------------------------------------------------------------
        }
    }

    //// =======================================================================

    stream << std::endl;
}
